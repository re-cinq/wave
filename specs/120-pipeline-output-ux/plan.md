# Implementation Plan: Pipeline Output UX — Surface Key Outcomes

**Branch**: `120-pipeline-output-ux` | **Date**: 2026-02-20 | **Spec**: `specs/120-pipeline-output-ux/spec.md`
**Input**: Feature specification from `specs/120-pipeline-output-ux/spec.md`

## Summary

Replace the current "wall of text" pipeline completion output with a structured outcome summary that prominently displays key results (branch, push status, PR/issue URLs, reports) and relegates verbose artifact/contract details to secondary display. The implementation extends the existing `deliverable.Tracker` with two new type constants (`TypeBranch`, `TypeIssue`), instruments the executor to record branch/push outcomes, introduces a `PipelineOutcome` struct in the display package for structured aggregation, and modifies `run.go` to render a prioritized outcome summary with contextual next steps. JSON output gets a structured `outcomes` field in the final completion event.

## Technical Context

**Language/Version**: Go 1.25+
**Primary Dependencies**: None new — uses existing `internal/display/` Formatter, `internal/deliverable/` Tracker, `internal/event/` NDJSONEmitter
**Storage**: N/A — `PipelineOutcome` is an in-memory read-only struct, not persisted
**Testing**: `go test` with table-driven tests (existing convention)
**Target Platform**: Cross-platform CLI (TTY + non-TTY, auto/text/json/quiet modes)
**Project Type**: Single Go binary
**Performance Goals**: No performance-sensitive paths — outcome rendering happens once post-pipeline
**Constraints**: Must not add new CLI flags (reuse `--verbose`); must not break existing JSON consumers
**Scale/Scope**: 6 files modified, 1 new file created, ~400 LOC new code + ~200 LOC tests

## Constitution Check

_GATE: Must pass before Phase 0 research. Re-check after Phase 1 design._

| Principle | Status | Notes |
|-----------|--------|-------|
| 1. Single Binary | Pass | No new dependencies |
| 2. Manifest as SSOT | Pass | No manifest changes |
| 3. Persona-Scoped Boundaries | Pass | No persona execution changes |
| 4. Fresh Memory at Step Boundaries | Pass | Deliverables flow through tracker, not chat |
| 5. Navigator-First | Pass | No navigation changes |
| 6. Contracts at Every Handover | Pass | Contract validation unchanged; display only |
| 7. Relay via Summarizer | Pass | No relay changes |
| 8. Ephemeral Workspaces | Pass | No workspace isolation changes |
| 9. Credentials Never Touch Disk | Pass | No credential handling |
| 10. Observable Progress | **Enhanced** | Structured outcomes improve observability |
| 11. Bounded Recursion | Pass | No recursion changes |
| 12. Minimal Step State Machine | Pass | No new step states; outcomes are post-pipeline |
| 13. Test Ownership | Pass | Plan includes tests for all new code |

No violations. No complexity tracking entries needed.

## Project Structure

### Documentation (this feature)

```
specs/120-pipeline-output-ux/
├── plan.md              # This file
├── research.md          # Phase 0 research findings and decisions
├── data-model.md        # Phase 1 entity definitions
└── tasks.md             # Phase 2 output (generated by /speckit.tasks)
```

### Source Code (repository root)

```
internal/
├── deliverable/
│   ├── types.go         # MODIFY: Add TypeBranch, TypeIssue constants + constructors + icons
│   └── tracker.go       # MODIFY: Add AddBranch(), AddIssue(), UpdateMetadata() methods
├── display/
│   └── outcome.go       # NEW: PipelineOutcome struct, OutcomeSummary renderer, BuildOutcome()
├── event/
│   └── emitter.go       # MODIFY: Add OutcomesJSON type, Outcomes field on Event
└── pipeline/
    └── executor.go      # MODIFY: Record branch deliverables on worktree creation, detect issues

cmd/wave/commands/
└── run.go               # MODIFY: Build PipelineOutcome, render via OutcomeSummary, emit JSON outcomes
```

**Structure Decision**: This feature modifies existing packages only, with one new file (`outcome.go`) in the display package. All changes follow the existing package structure and responsibilities.

## Implementation Layers

### Layer 1: Deliverable Type Extensions

**Scope**: `internal/deliverable/types.go` and `internal/deliverable/tracker.go`

Changes:
1. Add `TypeBranch` and `TypeIssue` constants to the `DeliverableType` const block
2. Add `NewBranchDeliverable()` and `NewIssueDeliverable()` constructor functions
3. Add icon cases for `TypeBranch` and `TypeIssue` in `Deliverable.String()`
4. Add `Tracker.AddBranch()` and `Tracker.AddIssue()` convenience methods
5. Add `Tracker.UpdateMetadata()` for post-creation metadata updates (push status)

**Dependencies**: None — this is the foundation layer.

**Test coverage**:
- Constructor tests for new deliverable types
- `GetByType()` queries for `TypeBranch` and `TypeIssue`
- `UpdateMetadata()` test with push status update
- `String()` rendering for new types (both nerd font and ASCII paths)

### Layer 2: Executor Instrumentation

**Scope**: `internal/pipeline/executor.go`

Changes:
1. After worktree creation (line ~800), call `e.deliverableTracker.AddBranch(step.ID, branch, absPath, "Feature branch")`
2. In `trackCommonDeliverables()`, add issue URL detection: scan results for `issue_url` key and `github.com/.*/issues/\d+` patterns
3. After publish steps (detected by step ID or by PR/push results), update branch deliverable metadata with push status via `UpdateMetadata(TypeBranch, branchName, "pushed", true)`

**Dependencies**: Layer 1 (new types and methods).

**Test coverage**:
- Verify branch deliverable is recorded when worktree workspace is created
- Verify issue deliverables are detected from step results
- Verify push status metadata is updated after publish step completion

### Layer 3: Outcome Aggregation & Rendering

**Scope**: `internal/display/outcome.go` (new file)

Types:
- `PipelineOutcome` — aggregated outcome data from deliverables + execution metadata
- `OutcomeLink`, `OutcomeFile`, `ContractFailure`, `NextStep` — supporting types
- `BuildOutcome()` — constructs `PipelineOutcome` from `*deliverable.Tracker` and metadata
- `RenderOutcomeSummary()` — renders human-readable summary using `Formatter`

Logic in `BuildOutcome()`:
1. Extract branch deliverables → populate `Branch`, `Pushed`, `RemoteRef`, `PushError`
2. Extract PR deliverables → populate `PullRequests` as `[]OutcomeLink`
3. Extract issue deliverables → populate `Issues`
4. Extract deployment deliverables → populate `Deployments`
5. Count artifact/contract/log deliverables → `ArtifactCount`, `ContractsPassed`, etc.
6. Extract top 5 outcome-worthy files by priority ordering
7. Generate next steps based on outcome data

Logic in `RenderOutcomeSummary()`:
1. Print "Outcomes" header
2. For each non-empty outcome category, render with label and icon
3. Print artifact/contract summary counts (single lines)
4. If verbose, print full deliverable list after summary
5. Print "Next Steps" if any and not quiet mode
6. Use `Formatter` for all ANSI formatting (auto-disabled in non-TTY)
7. Suppress empty categories per FR-008

**Dependencies**: Layer 1 (deliverable types), `internal/display/formatter.go`.

**Test coverage**:
- `BuildOutcome()` with various deliverable combinations
- `RenderOutcomeSummary()` output verification for default and verbose modes
- Empty outcome suppression (FR-008)
- Non-TTY plain text output (no ANSI codes)
- Large deliverable list truncation (top 5)
- Contract failure prominence in all modes
- Next steps generation rules

### Layer 4: Event Extension (JSON Output)

**Scope**: `internal/event/emitter.go`

Changes:
1. Add `OutcomesJSON` struct with `branch`, `pushed`, `pull_requests`, `issues`, `deliverables` fields
2. Add `OutcomeLinkJSON` and `DeliverableJSON` supporting types
3. Add `Outcomes *OutcomesJSON` field to `Event` struct with `json:"outcomes,omitempty"` tag

**Dependencies**: None — type-only change.

**Test coverage**:
- JSON serialization of Event with Outcomes field populated
- JSON serialization of Event with nil Outcomes (omitted)
- Backward compatibility: existing consumers see no change when Outcomes is nil

### Layer 5: Run Command Integration

**Scope**: `cmd/wave/commands/run.go`

Changes to `runRun()` (lines 337-364):
1. After `result.Cleanup()`, construct `PipelineOutcome` via `display.BuildOutcome()`
2. For auto/text modes: call `display.RenderOutcomeSummary()` instead of raw `executor.GetDeliverables()`
3. For JSON mode: convert `PipelineOutcome` to `OutcomesJSON`, attach to final completion event
4. For quiet mode: no changes (outcomes suppressed by design)

Inputs to `BuildOutcome()`:
- `executor.GetDeliverableTracker()` — the raw deliverable tracker
- `executor.GetTotalTokens()` — token count
- `elapsed` — duration
- `opts.Output.Verbose` — verbose flag
- `p.Metadata.Name` — pipeline name
- `runID` — run identifier

**Dependencies**: Layers 1-4.

**Test coverage**:
- Integration test: mock pipeline with branch, PR, artifacts → verify outcome summary output
- JSON mode: verify `outcomes` field in final event
- Quiet mode: verify outcomes suppressed
- Verbose mode: verify full deliverable list follows summary

## Edge Case Handling

| Edge Case | Handling | FR/Spec Reference |
|-----------|----------|-------------------|
| Failed step deliverables | Shown with "[FAILED]" prefix in outcomes | Edge Case 1 |
| Narrow terminal (<60 cols) | `Formatter.Truncate()` for long paths, wrapping for labels | Edge Case 2 |
| 50+ deliverables | Default: top 5 by type priority + count. Verbose: all | Edge Case 3 (C-002) |
| Long file paths/URLs | Relative to workspace root in default; full in verbose | Edge Case 4 |
| Non-TTY (piped output) | `Formatter` auto-disables ANSI; plain text only | Edge Case 5 |
| Push failure | Warning in outcomes: "Push failed: <error>" | Edge Case 6 |

## Complexity Tracking

_No constitution violations. No complexity justification needed._

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|-----------|--------------------------------------|
| (none) | — | — |
