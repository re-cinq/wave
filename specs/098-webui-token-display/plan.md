# Implementation Plan: Web UI Token Display

**Branch**: `098-webui-token-display` | **Date**: 2026-02-13 | **Spec**: [specs/098-webui-token-display/spec.md](spec.md)
**Input**: Feature specification from `/specs/098-webui-token-display/spec.md`

## Summary

Fix incorrect token counts and add missing token display to the web UI, ensuring parity with the TUI. The feature extends `FormatTokenCount` to handle M/B thresholds, adds a `formatTokens` template function to HTML templates, modifies step card/run row/run detail templates to display formatted tokens, enhances the SSE client to update tokens in real-time, and ensures the TUI completion summary always shows tokens.

## Technical Context

**Language/Version**: Go 1.25+
**Primary Dependencies**: `html/template` (stdlib), `net/http` (stdlib), existing Wave packages (`internal/display`, `internal/webui`, `internal/event`, `internal/pipeline`)
**Storage**: SQLite via `internal/state` (existing `pipeline_run.total_tokens` and `event_log.tokens_used` columns)
**Testing**: `go test ./...` with `-race` flag
**Target Platform**: Linux (single binary, web UI behind `//go:build webui` tag)
**Project Type**: Single Go project with embedded web UI assets
**Performance Goals**: SSE token updates visible within 1 second of step completion (SC-003)
**Constraints**: No new dependencies, no database schema changes, no new API endpoints
**Scale/Scope**: 7 files modified, ~100 lines of Go + ~30 lines of JS/HTML changes

## Constitution Check

_GATE: Must pass before Phase 0 research. Re-check after Phase 1 design._

| Principle | Status | Notes |
|-----------|--------|-------|
| P1: Single Binary | PASS | No new dependencies. All changes are to existing Go packages and embedded templates. |
| P2: Manifest as Single Source of Truth | PASS | No manifest changes. |
| P3: Persona-Scoped Execution | N/A | No persona or adapter changes. |
| P4: Fresh Memory at Step Boundary | N/A | No pipeline execution changes. |
| P5: Navigator-First Architecture | N/A | No pipeline structure changes. |
| P6: Contracts at Every Handover | PASS | Token display contract added in `contracts/token-display.json`. |
| P7: Relay via Dedicated Summarizer | N/A | No relay/compaction changes. |
| P8: Ephemeral Workspaces | N/A | No workspace changes. |
| P9: Credentials Never Touch Disk | PASS | No credential handling changes. |
| P10: Observable Progress | PASS | Enhances observability by making token data visible in web UI (real-time via SSE). |
| P11: Bounded Recursion | N/A | No recursion changes. |
| P12: Minimal Step State Machine | N/A | No state machine changes. |
| P13: Test Ownership | PASS | All existing tests must pass. New tests added for `FormatTokenCount` M/B thresholds and template function registration. |

**Post-Phase 1 Re-check**: All principles still pass. No violations introduced.

## Project Structure

### Documentation (this feature)

```
specs/098-webui-token-display/
├── spec.md              # Feature specification
├── plan.md              # This file
├── research.md          # Phase 0 research output
├── data-model.md        # Phase 1 data model output
├── contracts/
│   └── token-display.json  # Token display validation contract
└── tasks.md             # Phase 2 output (generated by /speckit.tasks)
```

### Source Code (files to modify)

```
internal/display/
├── formatter.go          # Extend FormatTokenCount with M/B thresholds
└── formatter_test.go     # Add test cases for M/B formatting

internal/webui/
├── embed.go              # Register formatTokens template function
├── templates/
│   ├── run_detail.html   # Add total tokens to run-meta header
│   └── partials/
│       ├── step_card.html # Fix token display logic (FR-008)
│       └── run_row.html   # Use formatTokens for total tokens
└── static/
    └── sse.js            # Add JS formatTokens, update step card tokens via SSE

cmd/wave/commands/
└── run.go                # Always show tokens in TUI completion summary (FR-010)
```

**Structure Decision**: All changes are modifications to existing files within the established Wave project structure. No new packages or files beyond the spec artifacts.

## Implementation Details

### Change 1: Extend `FormatTokenCount` (FR-007)

**File**: `internal/display/formatter.go:500-505`

**Current**:
```go
func FormatTokenCount(tokens int) string {
    if tokens < 1000 {
        return fmt.Sprintf("%d", tokens)
    }
    return fmt.Sprintf("%.1fk", float64(tokens)/1000.0)
}
```

**New**:
```go
func FormatTokenCount(tokens int) string {
    if tokens < 1000 {
        return fmt.Sprintf("%d", tokens)
    }
    if tokens < 1_000_000 {
        return fmt.Sprintf("%.1fk", float64(tokens)/1000.0)
    }
    if tokens < 1_000_000_000 {
        return fmt.Sprintf("%.1fM", float64(tokens)/1_000_000.0)
    }
    return fmt.Sprintf("%.1fB", float64(tokens)/1_000_000_000.0)
}
```

**Tests to add** (`formatter_test.go`): Test vectors for 0, 842, 999, 1000, 1500, 999999, 1000000, 1500000, 999999999, 1000000000, 2300000000.

### Change 2: Register `formatTokens` template function

**File**: `internal/webui/embed.go:35-38`

Add `"formatTokens": formatTokensFunc` to the `template.FuncMap`. The function wraps `display.FormatTokenCount` to accept `interface{}` (int, int64) for template flexibility:

```go
import "github.com/recinq/wave/internal/display"

funcMap := template.FuncMap{
    "statusClass":    statusClass,
    "formatDuration": formatDuration,
    "formatTime":     formatTime,
    "formatTokens":   formatTokensFunc,
}

func formatTokensFunc(tokens interface{}) string {
    switch v := tokens.(type) {
    case int:
        return display.FormatTokenCount(v)
    case int64:
        return display.FormatTokenCount(int(v))
    default:
        return "0"
    }
}
```

### Change 3: Fix step card token display (FR-001, FR-008)

**File**: `internal/webui/templates/partials/step_card.html:16-17`

**Current**:
```html
{{if gt .TokensUsed 0}}<span>Tokens: {{.TokensUsed}}</span>{{end}}
```

**New**:
```html
{{if or (eq .State "completed") (eq .State "failed") (eq .State "running")}}<span>Tokens: {{formatTokens .TokensUsed}}</span>{{end}}
```

This shows tokens for completed steps (even if 0), failed steps, and running steps (cumulative). Pending steps have no token display.

### Change 4: Add total tokens to run detail header (FR-004)

**File**: `internal/webui/templates/run_detail.html:7`

**Current**:
```html
<p class="run-meta">Run ID: <code>{{.Run.RunID}}</code> | Started: {{formatTime .Run.StartedAt}}{{if .Run.Duration}} | Duration: {{.Run.Duration}}{{end}}</p>
```

**New**:
```html
<p class="run-meta">Run ID: <code>{{.Run.RunID}}</code> | Started: {{formatTime .Run.StartedAt}}{{if .Run.Duration}} | Duration: {{.Run.Duration}}{{end}} | Tokens: {{formatTokens .Run.TotalTokens}}</p>
```

### Change 5: Format tokens in run list (FR-002)

**File**: `internal/webui/templates/partials/run_row.html:8`

**Current**:
```html
<td>{{.TotalTokens}}</td>
```

**New**:
```html
<td>{{formatTokens .TotalTokens}}</td>
```

### Change 6: SSE client-side token updates (FR-005)

**File**: `internal/webui/static/sse.js`

**6a.** Add a JavaScript `formatTokens` function at the top of the file:
```javascript
function formatTokens(n) {
    if (n === undefined || n === null) return '0';
    if (n < 1000) return String(n);
    if (n < 1000000) return (n / 1000).toFixed(1) + 'k';
    if (n < 1000000000) return (n / 1000000).toFixed(1) + 'M';
    return (n / 1000000000).toFixed(1) + 'B';
}
```

**6b.** Update `createStepCard()` to use `formatTokens()` and show tokens for non-pending states:
```javascript
// Replace: if (step.tokens_used > 0) metaParts.push(...)
// With:
if (step.state === 'completed' || step.state === 'failed' || step.state === 'running') {
    metaParts.push('<span class="token-count">Tokens: ' + formatTokens(step.tokens_used) + '</span>');
}
```

**6c.** Add `updateStepCardTokens()` function and call it from `handleSSEEvent()`:
```javascript
function updateStepCardTokens(stepID, tokens) {
    var cards = document.querySelectorAll('.step-card');
    cards.forEach(function(card) {
        var idEl = card.querySelector('.step-id');
        if (idEl && idEl.textContent === stepID) {
            var meta = card.querySelector('.step-meta');
            if (meta) {
                var tokenSpan = meta.querySelector('.token-count');
                if (!tokenSpan) {
                    tokenSpan = document.createElement('span');
                    tokenSpan.className = 'token-count';
                    meta.appendChild(tokenSpan);
                }
                tokenSpan.textContent = 'Tokens: ' + formatTokens(tokens);
            }
        }
    });
}
```

**6d.** In `handleSSEEvent()`, add token update logic after step card state updates:
```javascript
if (data.step_id && data.tokens_used !== undefined) {
    updateStepCardTokens(data.step_id, data.tokens_used);
}
```

### Change 7: TUI completion summary always shows tokens (FR-010)

**File**: `cmd/wave/commands/run.go:322-331`

**Current**:
```go
totalTokens := executor.GetTotalTokens()
if totalTokens > 0 {
    fmt.Fprintf(os.Stderr, "\n  ✓ Pipeline '%s' completed successfully (%.1fs, %s tokens)\n",
        p.Metadata.Name, elapsed.Seconds(), display.FormatTokenCount(totalTokens))
} else {
    fmt.Fprintf(os.Stderr, "\n  ✓ Pipeline '%s' completed successfully (%.1fs)\n",
        p.Metadata.Name, elapsed.Seconds())
}
```

**New**:
```go
totalTokens := executor.GetTotalTokens()
fmt.Fprintf(os.Stderr, "\n  ✓ Pipeline '%s' completed successfully (%.1fs, %s tokens)\n",
    p.Metadata.Name, elapsed.Seconds(), display.FormatTokenCount(totalTokens))
```

Always show tokens, even when 0 (displays as "0 tokens").

## Requirement Traceability

| Requirement | Implementation Change | Verification |
|-------------|----------------------|-------------|
| FR-001 | Change 3 (step_card.html) | Step cards show per-step tokens |
| FR-002 | Change 5 (run_row.html) | Run list shows formatted total tokens |
| FR-003 | No change needed (adapter already reports accurately) | Existing adapter tests verify accuracy |
| FR-004 | Change 4 (run_detail.html) | Run detail header shows total tokens |
| FR-005 | Change 6 (sse.js) | SSE updates tokens in real-time |
| FR-006 | No change needed (store already persists correctly) | Existing state tests verify persistence |
| FR-007 | Change 1 (formatter.go) + Change 2 (embed.go) | New tests for M/B thresholds |
| FR-008 | Change 3 (step_card.html) + Change 6b (sse.js) | Zero tokens shown for completed/failed |
| FR-009 | No change needed (claude.go already sums cache tokens) | Existing adapter tests verify summation |
| FR-010 | Change 7 (run.go) | TUI always shows total tokens |

## Complexity Tracking

_No constitution violations. All changes are within existing architectural boundaries._

| Aspect | Complexity | Justification |
|--------|-----------|---------------|
| New template function | Low | One function registration, follows existing `formatTime`/`statusClass` pattern |
| JS formatting duplication | Low | ~6 lines of trivial threshold logic, acceptable for SSE client |
| Template modifications | Low | Additive changes to existing templates, no structural changes |
| FormatTokenCount extension | Low | Two additional threshold checks, backward-compatible |
