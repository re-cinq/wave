kind: WavePipeline
metadata:
  name: feature
  description: "Plan, implement, test, and commit a feature to a new branch"
  release: false

input:
  source: cli
  example: "add a --dry-run flag to the run command"

steps:
  - id: explore
    persona: navigator
    workspace:
      mount:
        - source: ./
          target: /project
          mode: readonly
    exec:
      type: prompt
      source: |
        Explore the codebase to plan this feature: {{ input }}

        ## Exploration

        1. **Understand the request**: What is being asked? Assess scope
           (small = 1-2 files, medium = 3-7, large = 8+).

        2. **Find related code**: Use Glob and Grep to find files related
           to the feature. Note paths, relevance, and key symbols.

        3. **Identify patterns**: Read key files. Document conventions that
           must be followed (naming, error handling, testing patterns).

        4. **Map affected modules**: Which packages are directly/indirectly affected?

        5. **Survey tests**: Find related test files, testing patterns, gaps.

        6. **Assess risks**: Breaking changes, performance, security implications.

        Include: feature, scope, related_files (path, relevance, reason, key_symbols),
        patterns_to_follow, affected_modules, test_files, risks, and timestamp.
    output_artifacts:
      - name: exploration
        path: .wave/output/exploration.json
        type: json
    handover:
      contract:
        type: json_schema
        source: .wave/output/exploration.json
        schema_path: .wave/contracts/feature-exploration.schema.json
        on_failure: retry
        max_retries: 2

  - id: plan
    persona: planner
    dependencies: [explore]
    memory:
      inject_artifacts:
        - step: explore
          artifact: exploration
          as: context
    workspace:
      mount:
        - source: ./
          target: /project
          mode: readonly
    exec:
      type: prompt
      source: |
        Create an implementation plan for this feature.

        Feature: {{ input }}

        Break the feature into ordered implementation steps:

        1. For each step: what to do, which files to modify, acceptance criteria
        2. Dependencies between steps
        3. What tests to write
        4. Complexity estimate per step (S/M/L)

        Include: feature, steps (id, title, description, files_to_modify, files_to_create,
        tests_to_write, acceptance_criteria, complexity, dependencies), total_complexity,
        branch_name_suggestion, commit_message_suggestion, and timestamp.
    output_artifacts:
      - name: plan
        path: .wave/output/plan.json
        type: json
    handover:
      contract:
        type: json_schema
        source: .wave/output/plan.json
        schema_path: .wave/contracts/feature-plan.schema.json
        on_failure: retry
        max_retries: 2

  - id: implement
    persona: craftsman
    dependencies: [plan]
    memory:
      inject_artifacts:
        - step: explore
          artifact: exploration
          as: context
        - step: plan
          artifact: plan
          as: plan
    workspace:
      type: worktree
      branch: "feat/{{ pipeline_id }}"
    exec:
      type: prompt
      source: |
        Implement the feature on this isolated worktree branch.

        Feature: {{ input }}

        ## Process

        1. **Implement step by step** following the plan:
           - Follow existing codebase patterns identified in exploration
           - Write tests alongside implementation
           - After each significant change, verify it compiles: `go build ./...`

        2. **Run full test suite**:
           ```bash
           go test ./... -count=1
           ```
           Fix any failures before proceeding.

        3. **Commit**:
           ```bash
           git add <specific-files>
           git commit -m "<commit_message_suggestion from plan>

           Implementation following plan:
           - S01: <title>
           - S02: <title>
           ..."
           ```

        Commit changes to the worktree branch.
    handover:
      contract:
        type: test_suite
        command: "{{ project.test_command }}"
        must_pass: true
        on_failure: retry
        max_retries: 3
    output_artifacts:
      - name: result
        path: .wave/output/result.md
        type: markdown

  # ── Publish ─────────────────────────────────────────────────────────
  - id: publish
    persona: craftsman
    dependencies: [implement]
    memory:
      inject_artifacts:
        - step: implement
          artifact: result
          as: result
    workspace:
      type: worktree
      branch: "feat/{{ pipeline_id }}"
    exec:
      type: prompt
      source: |
        PUBLISH — push the branch and create a pull request.

        ## Steps

        1. Push the branch:
           ```bash
           git push -u origin HEAD
           ```

        2. Create a pull request using the implementation result as context.
           Use `gh pr create` with a descriptive title based on the latest commit message
           and the implementation result as the PR body.

        3. Capture the PR URL, PR number, and branch name in the result.
    output_artifacts:
      - name: pr-result
        path: .wave/output/pr-result.json
        type: json
    outcomes:
      - type: pr
        extract_from: .wave/output/pr-result.json
        json_path: .pr_url
        label: "Pull Request"
