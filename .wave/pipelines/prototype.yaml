kind: WavePipeline
metadata:
  name: prototype
  description: "Prototype-driven development pipeline with 5 phases (9 steps): spec, docs, dummy, implement, pr-cycle"
  release: false

input:
  source: cli
  example: "build a REST API for user management with CRUD operations"

steps:
  # Phase 1: Spec - Requirements capture with speckit integration
  - id: spec
    persona: craftsman
    exec:
      type: prompt
      source: |
        You are beginning the specification phase of a prototype-driven development pipeline.

        Your goal is to analyze the project description and create a comprehensive feature specification:

        Project description: {{ input }}

        CRITICAL: Create both spec.md and requirements.md files:

        spec.md should contain the complete feature specification including:
        - Feature overview and business value
        - User stories with acceptance criteria
        - Functional requirements
        - Success criteria and measurable outcomes
        - Constraints and assumptions

        requirements.md should contain extracted requirements (optional additional detail).

        Use speckit integration where available to enhance specification quality.

        The specification must be technology-agnostic and focused on user value.

        Create artifact.json with your results.

    workspace:
      mount:
        - source: .
          target: /project
          mode: readwrite

    output_artifacts:
      - name: spec
        path: spec.md
        type: markdown
      - name: requirements
        path: requirements.md
        type: markdown
      - name: contract_data
        path: .wave/artifact.json
        type: json

    handover:
      contract:
        type: json_schema
        schema_path: .wave/contracts/spec-phase.schema.json
        must_pass: true
        max_retries: 2

  # Phase 2: Docs - Generate runnable documentation from specification
  - id: docs
    persona: philosopher
    dependencies: [spec]

    memory:
      inject_artifacts:
        - step: spec
          artifact: spec
          as: input-spec.md

    exec:
      type: prompt
      source: |
        You are in the documentation phase of prototype-driven development.

        Your goal is to create comprehensive, runnable documentation from the specification.

        Create feature documentation from the injected specification that includes:
        - User-friendly explanation of the feature
        - Usage examples and scenarios
        - Integration guide for developers
        - Stakeholder summary for non-technical audiences

        Generate VitePress-compatible markdown that can be served as runnable documentation.

        CRITICAL: Create both feature-docs.md and stakeholder-summary.md files.

        Create artifact.json with your results.

    workspace:
      mount:
        - source: .
          target: /project
          mode: readwrite

    output_artifacts:
      - name: feature-docs
        path: feature-docs.md
        type: markdown
      - name: stakeholder-summary
        path: stakeholder-summary.md
        type: markdown
      - name: contract_data
        path: .wave/artifact.json
        type: json

    handover:
      contract:
        type: json_schema
        schema_path: .wave/contracts/docs-phase.schema.json
        must_pass: true
        max_retries: 2

  # Phase 3: Dummy - Build authentic functional prototype
  - id: dummy
    persona: craftsman
    dependencies: [docs]

    memory:
      inject_artifacts:
        - step: docs
          artifact: feature-docs
          as: feature-docs.md
        - step: spec
          artifact: spec
          as: spec.md

    exec:
      type: prompt
      source: |
        You are in the dummy/prototype phase of development.

        Your goal is to create a working prototype with authentic I/O handling but stub business logic.

        Create a functional prototype that:
        - Handles real input and output properly
        - Implements all user interfaces and endpoints
        - Uses placeholder/stub implementations for business logic
        - Can be run and demonstrated to stakeholders
        - Shows the complete user experience flow

        Focus on proving the interface design and user flows work correctly.

        CRITICAL: Create prototype/ directory with working code and interfaces.md with interface definitions.

        Create artifact.json with your results.

    workspace:
      mount:
        - source: .
          target: /project
          mode: readwrite

    output_artifacts:
      - name: prototype
        path: prototype/
        type: binary
      - name: interface-definitions
        path: interfaces.md
        type: markdown
      - name: contract_data
        path: .wave/artifact.json
        type: json

    handover:
      contract:
        type: json_schema
        schema_path: .wave/contracts/dummy-phase.schema.json
        must_pass: true
        max_retries: 2

  # Phase 4: Implement - Transition to full implementation
  - id: implement
    persona: craftsman
    dependencies: [dummy]

    memory:
      inject_artifacts:
        - step: spec
          artifact: spec
          as: spec.md
        - step: docs
          artifact: feature-docs
          as: feature-docs.md
        - step: dummy
          artifact: prototype
          as: prototype/

    exec:
      type: prompt
      source: |
        You are in the implementation phase - transitioning from prototype to production code.

        Your goal is to provide implementation guidance and begin real implementation:
        - Review all previous artifacts for implementation readiness
        - Create implementation plan and checklist
        - Begin replacing stub logic with real implementations
        - Ensure test coverage for all functionality
        - Maintain compatibility with established interfaces

        Focus on production-quality code that fulfills the original specification.

        CRITICAL: Create implementation-plan.md and implementation-checklist.md files.

        Create artifact.json with your results.

    workspace:
      mount:
        - source: .
          target: /project
          mode: readwrite

    output_artifacts:
      - name: implementation-plan
        path: implementation-plan.md
        type: markdown
      - name: progress-checklist
        path: implementation-checklist.md
        type: markdown
      - name: contract_data
        path: .wave/artifact.json
        type: json

    handover:
      contract:
        type: json_schema
        schema_path: .wave/contracts/implement-phase.schema.json
        must_pass: true
        max_retries: 2

  # Phase 5: PR-Cycle - Automated pull request lifecycle
  - id: pr-create
    persona: navigator
    dependencies: [implement]

    memory:
      inject_artifacts:
        - step: implement
          artifact: implementation-plan
          as: implementation-plan.md

    exec:
      type: prompt
      source: |
        You are creating a pull request for the implemented feature.

        Create a comprehensive pull request:
        - Clear PR title and description
        - Link to related issues
        - Include testing instructions
        - Add appropriate labels and reviewers
        - Request Copilot review

        Use GitHub CLI to create the PR and configure automated review workflow.

    workspace:
      mount:
        - source: .
          target: /project
          mode: readwrite

    output_artifacts:
      - name: pr-info
        path: pr-info.json
        type: json
    handover:
      contract:
        type: json_schema
        source: pr-info.json
        schema_path: .wave/contracts/pr-result.schema.json
        must_pass: true
        on_failure: retry
        max_retries: 2

  - id: pr-review
    persona: auditor
    dependencies: [pr-create]

    exec:
      type: prompt
      source: |
        Monitor and manage the PR review process.

        Poll for Copilot review completion and analyze feedback.
        Prepare response strategy for review comments.

    workspace:
      mount:
        - source: .
          target: /project
          mode: readwrite

  - id: pr-respond
    persona: philosopher
    dependencies: [pr-review]

    exec:
      type: prompt
      source: |
        Analyze review comments and prepare thoughtful responses.

        Generate responses to review feedback that:
        - Address technical concerns professionally
        - Explain design decisions clearly
        - Propose solutions for identified issues

    workspace:
      mount:
        - source: .
          target: /project
          mode: readwrite

  - id: pr-fix
    persona: craftsman
    dependencies: [pr-respond]

    exec:
      type: prompt
      source: |
        Implement small fixes based on review feedback.

        For larger changes, create follow-up issues instead of expanding this PR.
        Focus on quick, low-risk improvements that address reviewer concerns.

    workspace:
      mount:
        - source: .
          target: /project
          mode: readwrite

  - id: pr-merge
    persona: navigator
    dependencies: [pr-fix]

    exec:
      type: prompt
      source: |
        Complete the PR lifecycle with merge.

        Verify all checks pass, reviews are approved, and merge the PR.
        Clean up branch and notify stakeholders of completion.

    workspace:
      mount:
        - source: .
          target: /project
          mode: readwrite
