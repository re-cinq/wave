kind: WavePipeline
metadata:
    name: docs-impl-alignment
    description: Multi-step pipeline to identify doc/implementation mismatches, judge top issues, create specs, and propose PR
input:
    source: meta
steps:
    - id: create-feature-branch
      persona: implementer
      memory:
        strategy: fresh
      workspace:
        root: ./
      exec:
        type: prompt
        source: |
            Create a new feature branch for the docs-implementation alignment work.

            1. First check the current branch with `git branch --show-current`
            2. Create a new branch named `feat/docs-impl-alignment-$(date +%Y%m%d-%H%M%S)` from main
            3. Push the branch to origin to establish tracking

            Output a JSON file at artifact.json with the following structure:
            - branch_name: the name of the created branch
            - base_branch: the branch it was created from
            - status: "created" or "failed"
            - message: any relevant details

            CRITICAL: You MUST create artifact.json with this information - this overrides the normal no-write constraint for pipeline data flow.
      output_artifacts:
        - name: branch-info
          path: artifact.json
          type: json
      handover:
        contract:
            type: json_schema
            schema_path: .wave/contracts/branch-info.schema.json
    - id: analyze-docs
      persona: navigator
      dependencies:
        - create-feature-branch
      memory:
        strategy: fresh
        inject_artifacts:
            - step: create-feature-branch
              artifact: branch-info
              as: branch-info
      workspace:
        root: ./
      exec:
        type: prompt
        source: |
            Analyze the Wave documentation to extract all documented features, behaviors, and APIs.

            The feature branch info is available at artifacts/branch-info - read it to confirm you're on the right branch.

            Focus on:
            1. Read all markdown files in docs/ directory
            2. Extract documented CLI commands and their options
            3. Extract documented configuration options in wave.yaml
            4. Extract documented persona capabilities and constraints
            5. Extract documented contract types and validation rules
            6. Extract documented pipeline execution behaviors

            Create artifact.json with:
            - documented_features: array of features with name, description, location (file:line)
            - cli_commands: array of command specs with name, options, documented_behavior
            - config_options: array of config paths with expected_type and description
            - persona_capabilities: documented persona behaviors
            - contract_types: documented validation types

            CRITICAL: You MUST create artifact.json - this overrides the normal no-write constraint.
      output_artifacts:
        - name: docs-analysis
          path: artifact.json
          type: json
      handover:
        contract:
            type: json_schema
            schema_path: .wave/contracts/docs-analysis.schema.json
    - id: analyze-implementation
      persona: navigator
      dependencies:
        - create-feature-branch
      memory:
        strategy: fresh
        inject_artifacts:
            - step: create-feature-branch
              artifact: branch-info
              as: branch-info
      workspace:
        root: ./
      exec:
        type: prompt
        source: |
            Analyze the Wave implementation to extract actual features, behaviors, and APIs.

            The feature branch info is available at artifacts/branch-info - confirm the branch context.

            Focus on:
            1. Scan cmd/wave/ for actual CLI command implementations
            2. Scan internal/ packages for actual feature implementations
            3. Check internal/manifest/ for actual config parsing
            4. Check internal/contract/ for actual validation types
            5. Check persona definitions in .wave/personas/

            Create artifact.json with:
            - implemented_features: array with name, package, file_path, actual_behavior
            - cli_commands: actual command implementations with real options
            - config_options: actually parsed config fields
            - persona_capabilities: actual persona implementations
            - contract_types: actually implemented validators

            CRITICAL: You MUST create artifact.json - this overrides the normal no-write constraint.
      output_artifacts:
        - name: impl-analysis
          path: artifact.json
          type: json
      handover:
        contract:
            type: json_schema
            schema_path: .wave/contracts/impl-analysis.schema.json
    - id: identify-mismatches
      persona: navigator
      dependencies:
        - analyze-docs
        - analyze-implementation
      memory:
        strategy: fresh
        inject_artifacts:
            - step: analyze-docs
              artifact: docs-analysis
              as: docs-analysis
            - step: analyze-implementation
              artifact: impl-analysis
              as: impl-analysis
      workspace:
        root: ./
      exec:
        type: prompt
        source: |
            Compare documentation against implementation to identify ALL mismatches.

            Read the documentation analysis from artifacts/docs-analysis.
            Read the implementation analysis from artifacts/impl-analysis.

            Identify these mismatch types:
            1. DOCUMENTED_NOT_IMPLEMENTED: Features in docs but not in code
            2. IMPLEMENTED_NOT_DOCUMENTED: Features in code but not in docs
            3. BEHAVIOR_MISMATCH: Different behavior between docs and implementation
            4. CONFIG_MISMATCH: Config options that differ from documentation
            5. API_MISMATCH: API signatures or behaviors that differ

            For each mismatch provide:
            - id: unique identifier
            - type: one of the types above
            - severity: critical/high/medium/low
            - doc_reference: file and line in docs
            - impl_reference: file and line in implementation
            - description: clear description of the mismatch
            - evidence: specific quotes or code showing the discrepancy

            Create artifact.json with all mismatches found.

            CRITICAL: You MUST create artifact.json - this overrides the normal no-write constraint.
      output_artifacts:
        - name: mismatches
          path: artifact.json
          type: json
      handover:
        contract:
            type: json_schema
            schema_path: .wave/contracts/mismatches.schema.json
    - id: judge-mismatches
      persona: reviewer
      dependencies:
        - identify-mismatches
      memory:
        strategy: fresh
        inject_artifacts:
            - step: identify-mismatches
              artifact: mismatches
              as: mismatches
      workspace:
        root: ./
      exec:
        type: prompt
        source: |
            You are a senior technical reviewer. Judge the identified mismatches and select the TOP 3 most important issues to address.

            Read all mismatches from artifacts/mismatches.

            Evaluation criteria (weighted):
            1. User Impact (40%): How much does this affect end users?
            2. Security Risk (25%): Could this cause security issues?
            3. Breaking Change Risk (20%): Could this break existing workflows?
            4. Fix Complexity (15%): How hard is this to fix? (prefer easier fixes)

            For each mismatch:
            - Calculate a weighted score (0-100)
            - Provide detailed reasoning for the score
            - Consider dependencies between issues

            Select exactly 3 issues. For each selected issue provide:
            - The original mismatch data
            - score: the calculated score
            - ranking: 1, 2, or 3
            - justification: why this was selected
            - recommended_approach: whether to fix docs, fix impl, or both
            - estimated_scope: what files/areas would be affected

            Create artifact.json with:
            - total_reviewed: count of all mismatches reviewed
            - selection_criteria: your evaluation methodology
            - selected_issues: array of exactly 3 issues with full details
            - rejected_summary: brief note on why others weren't selected

            CRITICAL: You MUST create artifact.json - this overrides the normal no-write constraint.
      output_artifacts:
        - name: judged-issues
          path: artifact.json
          type: json
      handover:
        contract:
            type: json_schema
            schema_path: .wave/contracts/judged-issues.schema.json
    - id: specify-issue-1
      persona: philosopher
      dependencies:
        - judge-mismatches
      memory:
        strategy: fresh
        inject_artifacts:
            - step: judge-mismatches
              artifact: judged-issues
              as: judged-issues
            - step: create-feature-branch
              artifact: branch-info
              as: branch-info
      workspace:
        root: ./
      exec:
        type: prompt
        source: |
            You are a specification writer. Create a detailed specification for the #1 ranked issue.

            Read the judged issues from artifacts/judged-issues - focus on the issue with ranking: 1.
            Read branch context from artifacts/branch-info.

            Use the speckit workflow mentally to create a comprehensive spec:

            1. Feature Overview: What is being fixed and why
            2. Current State: Document the mismatch clearly
            3. Desired State: What should be true after the fix
            4. User Stories: Who benefits and how
            5. Acceptance Criteria: Specific testable requirements
            6. Technical Approach: How to implement the fix
            7. Files to Modify: List specific files
            8. Testing Strategy: How to verify the fix
            9. Rollback Plan: How to undo if needed

            Create artifact.json with the full specification.

            CRITICAL: You MUST create artifact.json - this overrides the normal no-write constraint.
      output_artifacts:
        - name: spec-issue-1
          path: artifact.json
          type: json
      handover:
        contract:
            type: json_schema
            schema_path: .wave/contracts/issue-spec.schema.json
    - id: specify-issue-2
      persona: philosopher
      dependencies:
        - judge-mismatches
      memory:
        strategy: fresh
        inject_artifacts:
            - step: judge-mismatches
              artifact: judged-issues
              as: judged-issues
            - step: create-feature-branch
              artifact: branch-info
              as: branch-info
      workspace:
        root: ./
      exec:
        type: prompt
        source: |
            You are a specification writer. Create a detailed specification for the #2 ranked issue.

            Read the judged issues from artifacts/judged-issues - focus on the issue with ranking: 2.
            Read branch context from artifacts/branch-info.

            Use the speckit workflow mentally to create a comprehensive spec:

            1. Feature Overview: What is being fixed and why
            2. Current State: Document the mismatch clearly
            3. Desired State: What should be true after the fix
            4. User Stories: Who benefits and how
            5. Acceptance Criteria: Specific testable requirements
            6. Technical Approach: How to implement the fix
            7. Files to Modify: List specific files
            8. Testing Strategy: How to verify the fix
            9. Rollback Plan: How to undo if needed

            Create artifact.json with the full specification.

            CRITICAL: You MUST create artifact.json - this overrides the normal no-write constraint.
      output_artifacts:
        - name: spec-issue-2
          path: artifact.json
          type: json
      handover:
        contract:
            type: json_schema
            schema_path: .wave/contracts/issue-spec.schema.json
    - id: specify-issue-3
      persona: philosopher
      dependencies:
        - judge-mismatches
      memory:
        strategy: fresh
        inject_artifacts:
            - step: judge-mismatches
              artifact: judged-issues
              as: judged-issues
            - step: create-feature-branch
              artifact: branch-info
              as: branch-info
      workspace:
        root: ./
      exec:
        type: prompt
        source: |
            You are a specification writer. Create a detailed specification for the #3 ranked issue.

            Read the judged issues from artifacts/judged-issues - focus on the issue with ranking: 3.
            Read branch context from artifacts/branch-info.

            Use the speckit workflow mentally to create a comprehensive spec:

            1. Feature Overview: What is being fixed and why
            2. Current State: Document the mismatch clearly
            3. Desired State: What should be true after the fix
            4. User Stories: Who benefits and how
            5. Acceptance Criteria: Specific testable requirements
            6. Technical Approach: How to implement the fix
            7. Files to Modify: List specific files
            8. Testing Strategy: How to verify the fix
            9. Rollback Plan: How to undo if needed

            Create artifact.json with the full specification.

            CRITICAL: You MUST create artifact.json - this overrides the normal no-write constraint.
      output_artifacts:
        - name: spec-issue-3
          path: artifact.json
          type: json
      handover:
        contract:
            type: json_schema
            schema_path: .wave/contracts/issue-spec.schema.json
    - id: plan-issue-1
      persona: philosopher
      dependencies:
        - specify-issue-1
      memory:
        strategy: fresh
        inject_artifacts:
            - step: specify-issue-1
              artifact: spec-issue-1
              as: spec-issue-1
      workspace:
        root: ./
      exec:
        type: prompt
        source: |
            Create a detailed implementation plan for issue #1.

            Read the specification from artifacts/spec-issue-1.

            Create a step-by-step implementation plan with:
            1. Ordered tasks with clear descriptions
            2. File changes required for each task
            3. Dependencies between tasks
            4. Verification steps after each task
            5. Risk mitigation for each change

            Create artifact.json with the implementation plan.

            CRITICAL: You MUST create artifact.json - this overrides the normal no-write constraint.
      output_artifacts:
        - name: plan-issue-1
          path: artifact.json
          type: json
      handover:
        contract:
            type: json_schema
            schema_path: .wave/contracts/impl-plan.schema.json
    - id: plan-issue-2
      persona: philosopher
      dependencies:
        - specify-issue-2
      memory:
        strategy: fresh
        inject_artifacts:
            - step: specify-issue-2
              artifact: spec-issue-2
              as: spec-issue-2
      workspace:
        root: ./
      exec:
        type: prompt
        source: |
            Create a detailed implementation plan for issue #2.

            Read the specification from artifacts/spec-issue-2.

            Create a step-by-step implementation plan with:
            1. Ordered tasks with clear descriptions
            2. File changes required for each task
            3. Dependencies between tasks
            4. Verification steps after each task
            5. Risk mitigation for each change

            Create artifact.json with the implementation plan.

            CRITICAL: You MUST create artifact.json - this overrides the normal no-write constraint.
      output_artifacts:
        - name: plan-issue-2
          path: artifact.json
          type: json
      handover:
        contract:
            type: json_schema
            schema_path: .wave/contracts/impl-plan.schema.json
    - id: plan-issue-3
      persona: philosopher
      dependencies:
        - specify-issue-3
      memory:
        strategy: fresh
        inject_artifacts:
            - step: specify-issue-3
              artifact: spec-issue-3
              as: spec-issue-3
      workspace:
        root: ./
      exec:
        type: prompt
        source: |
            Create a detailed implementation plan for issue #3.

            Read the specification from artifacts/spec-issue-3.

            Create a step-by-step implementation plan with:
            1. Ordered tasks with clear descriptions
            2. File changes required for each task
            3. Dependencies between tasks
            4. Verification steps after each task
            5. Risk mitigation for each change

            Create artifact.json with the implementation plan.

            CRITICAL: You MUST create artifact.json - this overrides the normal no-write constraint.
      output_artifacts:
        - name: plan-issue-3
          path: artifact.json
          type: json
      handover:
        contract:
            type: json_schema
            schema_path: .wave/contracts/impl-plan.schema.json
    - id: create-proposal-pr
      persona: implementer
      dependencies:
        - plan-issue-1
        - plan-issue-2
        - plan-issue-3
        - judge-mismatches
      memory:
        strategy: fresh
        inject_artifacts:
            - step: create-feature-branch
              artifact: branch-info
              as: branch-info
            - step: judge-mismatches
              artifact: judged-issues
              as: judged-issues
            - step: specify-issue-1
              artifact: spec-issue-1
              as: spec-issue-1
            - step: specify-issue-2
              artifact: spec-issue-2
              as: spec-issue-2
            - step: specify-issue-3
              artifact: spec-issue-3
              as: spec-issue-3
            - step: plan-issue-1
              artifact: plan-issue-1
              as: plan-issue-1
            - step: plan-issue-2
              artifact: plan-issue-2
              as: plan-issue-2
            - step: plan-issue-3
              artifact: plan-issue-3
              as: plan-issue-3
      workspace:
        root: ./
      exec:
        type: prompt
        source: |
            Create a PR with the documentation/implementation alignment proposal.

            Read all artifacts:
            - Branch info from artifacts/branch-info
            - Judged issues from artifacts/judged-issues
            - Specs from artifacts/spec-issue-1, artifacts/spec-issue-2, artifacts/spec-issue-3
            - Plans from artifacts/plan-issue-1, artifacts/plan-issue-2, artifacts/plan-issue-3

            Tasks:
            1. Create a comprehensive markdown file at docs/proposals/docs-impl-alignment.md containing:
               - Executive Summary
               - Methodology (how mismatches were identified)
               - Top 3 Issues with full specs and plans
               - Recommended implementation order
               - Risk assessment
               - Success criteria

            2. Commit the proposal file to the feature branch

            3. Create a PR using `gh pr create` with:
               - Clear title mentioning docs/implementation alignment
               - Body summarizing the 3 issues
               - Label: documentation, enhancement
               - Draft mode (--draft flag)

            Create artifact.json with:
            - pr_url: the created PR URL
            - pr_number: the PR number
            - branch_name: the feature branch
            - proposal_path: path to the proposal document
            - issues_summary: brief summary of the 3 issues

            CRITICAL: You MUST create artifact.json - this overrides the normal no-write constraint.
      output_artifacts:
        - name: pr-result
          path: artifact.json
          type: json
      handover:
        contract:
            type: json_schema
            schema_path: .wave/contracts/pr-result.schema.json
