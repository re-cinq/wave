kind: WavePipeline
metadata:
  name: feature-worktree
  description: "Plan and implement a feature using git worktree isolation and preflight dependency checks"

requires:
  tools: [git, go]

input:
  source: cli
  example: "add a --dry-run flag to the run command"

steps:
  - id: explore
    persona: navigator
    memory:
      strategy: fresh
    workspace:
      mount:
        - source: ./
          target: /project
          mode: readonly
    exec:
      type: prompt
      source: |
        Explore the codebase to plan this feature: {{ input }}

        ## Exploration

        1. **Understand the request**: What is being asked? Assess scope
           (small = 1-2 files, medium = 3-7, large = 8+).

        2. **Find related code**: Use Glob and Grep to find files related
           to the feature. Note paths, relevance, and key symbols.

        3. **Identify patterns**: Read key files. Document conventions that
           must be followed (naming, error handling, testing patterns).

        4. **Map affected modules**: Which packages are directly/indirectly affected?

        5. **Survey tests**: Find related test files, testing patterns, gaps.

        6. **Assess risks**: Breaking changes, performance, security implications.

        Write the result as JSON to output/exploration.json with fields:
        feature, scope, related_files, patterns_to_follow, affected_modules,
        test_files, risks, and timestamp.
    output_artifacts:
      - name: exploration
        path: output/exploration.json
        type: json

  - id: implement
    persona: craftsman
    dependencies: [explore]
    memory:
      strategy: fresh
      inject_artifacts:
        - step: explore
          artifact: exploration
          as: context
    workspace:
      type: worktree
      branch: "feat/{{ pipeline_name }}"
    exec:
      type: prompt
      source: |
        Implement the feature on this isolated worktree branch.

        Read the exploration: cat artifacts/context

        Feature: {{ input }}

        ## Process

        1. **Implement step by step** following the exploration findings:
           - Follow existing codebase patterns identified in exploration
           - Write tests alongside implementation
           - After each significant change, verify it compiles: `go build ./...`

        2. **Run full test suite**:
           ```bash
           go test ./... -count=1
           ```
           Fix any failures before proceeding.

        3. **Commit**:
           ```bash
           git add <specific-files>
           git commit -m "feat: <concise description>"
           ```

        Do NOT push or create a PR â€” just commit to this worktree branch.
    handover:
      contract:
        type: test_suite
        command: "go test ./..."
        must_pass: true
        on_failure: retry
        max_retries: 3
    output_artifacts:
      - name: result
        path: output/result.md
        type: markdown
