kind: WavePipeline
metadata:
  name: implement
  description: "Plan, implement, test, and commit changes to a feature branch"
  release: true

input:
  source: cli
  example: "add JSON output format to the status command"

steps:
  - id: plan
    persona: planner
    memory:
      strategy: fresh
    workspace:
      mount:
        - source: ./
          target: /src
          mode: readonly
    exec:
      type: prompt
      source: |
        Explore the codebase and plan the implementation: {{ input }}

        ## Process

        1. **Explore**: Find all files related to the task. Read key files
           to understand patterns, conventions, and architecture.

        2. **Plan**: Break the work into ordered steps with:
           - Files to create or modify
           - What changes to make in each file
           - Tests to write
           - Acceptance criteria

        3. **Estimate**: Assess complexity and identify risks.

        Write JSON to output/impl-plan.json:

        {
          "task": "what is being implemented",
          "exploration": {
            "related_files": [
              {"path": "file.go", "reason": "why relevant"}
            ],
            "patterns": ["pattern to follow"],
            "constraints": ["constraint to respect"]
          },
          "steps": [
            {
              "id": "S01",
              "title": "step title",
              "description": "detailed what to do",
              "files": ["path.go"],
              "tests": ["test description"],
              "acceptance": ["criterion"],
              "complexity": "S|M|L"
            }
          ],
          "branch_name": "feat/or-fix/descriptive-name",
          "commit_message": "feat: or fix: concise description",
          "total_complexity": "S|M|L|XL",
          "risks": ["potential issue"],
          "timestamp": "ISO 8601 datetime"
        }

        CRITICAL: Write ONLY valid JSON to output/impl-plan.json.
    output_artifacts:
      - name: plan
        path: output/impl-plan.json
        type: json
    handover:
      contract:
        type: json_schema
        source: output/impl-plan.json
        schema_path: .wave/contracts/impl-plan-lean.schema.json
        on_failure: retry
        max_retries: 2

  - id: build
    persona: craftsman
    dependencies: [plan]
    memory:
      strategy: fresh
      inject_artifacts:
        - step: plan
          artifact: plan
          as: plan
    workspace:
      mount:
        - source: ./
          target: /src
          mode: readwrite
    exec:
      type: prompt
      source: |
        Implement the plan and commit to a feature branch.

        Read the plan: cat artifacts/plan

        ## Process

        1. **Create branch**:
           ```bash
           cd "$(git rev-parse --show-toplevel)"
           BRANCH="<branch_name from plan>"
           git checkout -b "$BRANCH"
           ```

        2. **Implement step by step**:
           - Follow the plan's step order
           - Write tests alongside code
           - After each step, verify: `go build ./...`
           - Follow codebase patterns noted in the plan

        3. **Run full test suite**:
           ```bash
           go test ./... -count=1
           ```

        4. **Commit**:
           ```bash
           git add <specific-files>
           git commit -m "<commit_message from plan>"
           ```

        5. **Push**:
           ```bash
           git push -u origin "$BRANCH" 2>/dev/null || true
           ```
    handover:
      contract:
        type: test_suite
        command: "go test ./... -count=1"
        must_pass: true
        on_failure: retry
        max_retries: 3

  - id: review
    persona: auditor
    dependencies: [build]
    memory:
      strategy: fresh
      inject_artifacts:
        - step: plan
          artifact: plan
          as: original_plan
    exec:
      type: prompt
      source: |
        Review the implementation against the plan.

        Read the original plan: cat artifacts/original_plan

        Check:
        1. Were all planned steps implemented?
        2. Do the changes match the plan's acceptance criteria?
        3. Are tests comprehensive and meaningful?
        4. Is the code consistent with codebase patterns?
        5. Are there any security or performance concerns?
        6. Is the commit clean (no unrelated changes)?

        Output a review to output/review.md:
        - Plan adherence: which steps completed, which skipped
        - Code quality assessment
        - Test coverage assessment
        - Issues found (if any)
        - Overall verdict: APPROVE / NEEDS_WORK
    output_artifacts:
      - name: review
        path: output/review.md
        type: markdown
