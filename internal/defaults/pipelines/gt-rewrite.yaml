kind: WavePipeline
metadata:
  name: gt-rewrite
  description: "Analyze and rewrite poorly documented Gitea issues"
  release: true

input:
  source: cli
  example: "re-cinq/wave 42"
  schema:
    type: string
    description: "Gitea repository, optionally with issue number (e.g. 'owner/repo' or 'owner/repo 42')"

steps:
  - id: scan-issues
    persona: gitea-analyst
    workspace:
      type: worktree
      branch: "{{ pipeline_id }}"
    exec:
      type: prompt
      source: |
        MANDATORY: You MUST call the Bash tool. NEVER say "tea CLI not installed" without trying.

        Input: {{ input }}

        Parse the input to determine the mode:
        - If the input contains a number after the repo (e.g. "re-cinq/wave 42"), this is SINGLE ISSUE mode.
          Extract the repo (first token) and issue number (second token).
        - If the input is just a repo (e.g. "re-cinq/wave"), this is BATCH mode.

        Execute these commands using the Bash tool:

        1. tea --version

        2a. SINGLE ISSUE mode: Parse the repo and number from {{ input }}, then run:
            tea issues view <NUMBER> --repo <REPO> --json number,title,body,labels,url
        2b. BATCH mode: tea issues list --repo {{ input }} --limit 10 --json number,title,body,labels,url

        After getting REAL results from Bash, analyze issues and score them.
        In single issue mode, analyze the one issue. In batch mode, analyze all returned issues.
    output_artifacts:
      - name: issue_analysis
        path: .wave/artifact.json
        type: json
        required: true
    handover:
      max_retries: 1
      contract:
        type: json_schema
        schema_path: .wave/contracts/github-issue-analysis.schema.json
        validate: true
        must_pass: true
        allow_recovery: true
        recovery_level: progressive
        progressive_validation: false

  - id: plan-enhancements
    persona: gitea-analyst
    dependencies: [scan-issues]
    memory:
      inject_artifacts:
        - step: scan-issues
          artifact: issue_analysis
          as: analysis
    workspace:
      type: worktree
      branch: "{{ pipeline_id }}"
    exec:
      type: prompt
      source: |
        The analysis artifact contains poor_quality_issues from the scan step.

        For EACH issue in poor_quality_issues, use tea CLI to fetch the current body:
        tea issues view <NUMBER> --repo {{ input }} --json body

        Then create an enhancement plan with:
        - issue_number: the issue number
        - suggested_title: improved title (or keep original if good)
        - body_template: enhanced body text (improve the existing body, add missing sections)
        - suggested_labels: appropriate labels
        - enhancements: list of changes being made

        Create an enhancement plan with fields:
        issues_to_enhance (array of issue_number, suggested_title, body_template,
        suggested_labels, enhancements) and total_to_enhance.
    output_artifacts:
      - name: enhancement_plan
        path: .wave/artifact.json
        type: json
        required: true
    handover:
      max_retries: 1
      contract:
        type: json_schema
        schema_path: .wave/contracts/github-enhancement-plan.schema.json
        validate: true
        must_pass: true
        allow_recovery: true
        recovery_level: progressive
        progressive_validation: false

  - id: apply-enhancements
    persona: gitea-enhancer
    dependencies: [plan-enhancements]
    memory:
      inject_artifacts:
        - step: plan-enhancements
          artifact: enhancement_plan
          as: plan
    workspace:
      type: worktree
      branch: "{{ pipeline_id }}"
    exec:
      type: prompt
      source: |
        CRITICAL: You MUST use the Bash tool for all commands. Do NOT generate fake output.

        Step 1: Use Bash tool to verify tea works:
        tea --version

        Step 2: For EACH issue in the plan, use Bash tool to apply changes:
        - If suggested_title differs from current: tea issues edit <N> --repo {{ input }} --title "suggested_title"
        - If body_template is provided: tea issues edit <N> --repo {{ input }} --body "body_template"
        - If suggested_labels: tea issues edit <N> --repo {{ input }} --add-label "label1,label2"

        Step 4: For each issue, capture the URL: tea issues view <N> --repo {{ input }} --json url --jq .url

        Step 5: Record the results with fields: enhanced_issues (each with issue_number,
        success, changes_made, url), total_attempted, total_successful, total_failed.
    output_artifacts:
      - name: enhancement_results
        path: .wave/artifact.json
        type: json
        required: true
    outcomes:
      - type: issue
        extract_from: .wave/artifact.json
        json_path: .enhanced_issues[0].url
        label: "Enhanced Issue"
    handover:
      max_retries: 1
      contract:
        type: json_schema
        schema_path: .wave/contracts/github-enhancement-results.schema.json
        validate: true
        must_pass: true
        allow_recovery: true
        recovery_level: progressive
        progressive_validation: false

  - id: verify-enhancements
    persona: gitea-analyst
    dependencies: [apply-enhancements]
    memory:
      inject_artifacts:
        - step: apply-enhancements
          artifact: enhancement_results
          as: results
        - step: scan-issues
          artifact: issue_analysis
          as: original_analysis
    workspace:
      type: worktree
      branch: "{{ pipeline_id }}"
    exec:
      type: prompt
      source: |
        For each enhanced issue, verify with: tea issues view <N> --repo {{ input }} --json title,labels

        Compile a verification report with fields:
        total_enhanced, successful_enhancements, failed_enhancements, and summary.
    output_artifacts:
      - name: verification_report
        path: .wave/artifact.json
        type: json
        required: true
    handover:
      max_retries: 1
      contract:
        type: json_schema
        schema_path: .wave/contracts/github-verification-report.schema.json
        validate: true
        must_pass: true
        allow_recovery: true
        recovery_level: progressive
        progressive_validation: false
